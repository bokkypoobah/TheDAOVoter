#!/usr/bin/perl -W
# 
# Copyright (c) 2016 BokkyPooBah.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in 
# the Software without restriction, including without limitation the rights to 
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
# of the Software, and to permit persons to whom the Software is furnished to do 
# so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# 

use strict;
use Getopt::Long qw(:config no_auto_abbrev);
use Text::Wrap;

# Adjust $GETHBINARY to point to geth if it is not on your search path
my $GETHBINARY = "geth";
my $THEDAOADDRESS = "0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413";
my $THEDAOFIRSTBLOCK = 1601755;
my $DEFAULTFIRST = 1;
my $DEFAULTSPLIT = "exclude";
my $DEFAULTSTATUS = "open";
my $VOTESIGNATUREHASH = "0xc9d27afe"; # web3.sha3('vote(uint256,bool)').substr(0, 10) == "0xc9d27afe"
my $ESTIMATEGASMAXGAS = 1000000;
my $ESTIMATEDGASVOTING = 100000;
my $UNLOCKACCOUNTSECONDS = 2;
my $DEFAULTETHDECIMALPLACES = 18;
my $DEFAULTDAODECIMALPLACES = 16;

my $helptext = qq\
The DAO Voter v1.0000000000000006 06/06/2016. https://github.com/BokkyPooBah/TheDAOVoter

Usage: $0 {command} [options]

Commands are:
  --listaccounts
  --listproposals
  --sumsplits
  --vote
  --help

The --listaccounts command has no additional optional parameters other than the general 
parameters listed below.

The --listproposals command has additional optional parameters:
  --id={proposal id}               Proposal id.
  --first={first proposal id}      First proposal id. Default '$DEFAULTFIRST'.
  --last={last proposal id}        Last proposal id. Default last proposal id.
  --split={exclude|include|only}   Include splits. Default '$DEFAULTSPLIT'.
  --status={open|closed|both}      Proposal status. Default '$DEFAULTSTATUS'.
  --checkvotingstatus              Check your voting status for the proposals. Default off. This
                                   check uses eth.estimateGas() API call to determine if you have
                                   already voted.
  --checkpastvotes                 Retrieve your past voting history. Default off. Actual gas used
                                   will be reported in the (Est)Gas column

The --sumsplits command has no additional option.

The --vote command has the additional options:
  --id={proposal id}               Proposal id.
  --support={0|n|1|y}              Don't support (0 or n) or support (1 or y) proposal.
  --force                          Force a vote even when this tool reports that you have already voted.

There following options can be use generally:
  --account={account or id}        Use account number (e.g. 1) or address (e.g. 0xabc...)
  --decimalplaces={decimal places) Number of decimal places. Default ETH '$DEFAULTETHDECIMALPLACES', DAO '$DEFAULTDAODECIMALPLACES'.
  --verbose                        Display what this script is doing.

HISTORY
  v1.0000000000000000 02/06/2016 First version
  v1.0000000000000001 03/06/2016 Tidy
  v1.0000000000000002 03/06/2016 Added --checkpastvotes by retrieving The DAO Voted(...) events
  v1.0000000000000003 04/06/2016 Display account The DAO token blocked status and unblock time
  v1.0000000000000004 05/06/2016 --sumsplits to list the sum of splits
                                 --account can now be used to specify an account not in your keystore
  v1.0000000000000005 05/06/2016 --decimalplaces
  v1.0000000000000006 05/06/2016 Improved error handling, displaying durations with time


REQUIREMENTS - This script runs on Linux and perhaps OSX. You can try it with Cygwin Perl, Strawberry Perl
or ActiveState Perl on Windows. 

You will need to have geth (go Ethereum node software) on your path. geth is available from 
https://github.com/ethereum/go-ethereum/releases .

geth is also packaged with the Ethereum Wallet (Mist) downloads. You will find the geth binary in the Ethereum
Wallet subdirectory under resources/node/geth/geth . Modify the GETHBINARY variable above to point to your geth path
if necessary.


NOTE - Only the --vote command will require you to enter your password to unlock your geth keystore. Check the code
below if you are concerned. The other --listaccounts and --listproposals commands do not require the unlocking of
your geth keystore.


WARNING - This script uses the same method as the Ethereum Wallet (Mist) to unlock your account in geth
when you are sending your vote to the Ethereum blockchain. Make sure that you start geth without the 
--rpc option when using geth with this script. See the following URL about the security issues with this keystore
unlocking methodology:
http://ethereum.stackexchange.com/questions/3887/how-to-reduce-the-chances-of-your-ethereum-wallet-getting-hacked


The more frequently used commands follow:
  This help
    $0
  List accounts and display whether the account is blocked by votes in progress
    $0 --listaccounts
  List proposals (excluding splits, open proposals only)
    $0 --listproposals 
  List proposals (excluding splits, open proposals only) and check voting status for your accounts
    $0 --listproposals --checkvotingstatus
  List proposals #2 and check voting status for your accounts
    $0 --listproposals --id=2 --checkvotingstatus
  List open proposals and check voting status and past votes for your accounts
    $0 --listproposals --checkvotingstatus --checkpastvotes
  View split proposal statistics
    $0 --sumsplits
  Vote on proposal #2 from account #1 in your keystore, not supporting this vote
    $0 --vote --id=2 --account=1 --support=0
  Vote on proposal #43 from account 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, supporting this vote
    $0 --vote --id=43 --account=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa --support=1


Donations happily accepted to Ethereum account 0xbeef281b81d383336aca8b2b067a526227638087.

Enjoy, and vote well. BokkyPooBah 2016.

Stopped\;

my ($listAccounts, $listProposals, $sumSplits, $vote);
my ($id, $first, $last, $split, $proposalStatus, $checkVotingStatus, $checkPastVotes, $account, $support, $force);
my ($help, $verbose, $decimalPlaces);
my $status = 0;

GetOptions(
  "listaccounts"        => \$listAccounts,
  "listproposals"       => \$listProposals,
  "sumsplits"           => \$sumSplits,
  "vote"                => \$vote,
  "help"                => \$help,
  "verbose"             => \$verbose,
  "decimalPlaces:n"     => \$decimalPlaces,
  "id:n"                => \$id,
  "first:n"             => \$first,
  "last:n"              => \$last,
  "status:s"            => \$proposalStatus,
  "split:s"             => \$split,
  "checkVotingStatus"   => \$checkVotingStatus,
  "checkpastvotes"      => \$checkPastVotes,
  "account:s"           => \$account,
  "support:s"           => \$support,
  "force"               => \$force)
or die $helptext;

my ($terminalWidth) = `stty size` =~ /\d+\s+(\d+)/;
$Text::Wrap::columns = $terminalWidth;

my ($ethDecimalPlaces, $ethNumberLength, $daoDecimalPlaces, $daoNumberLength);
if (defined $decimalPlaces) {
  if ($decimalPlaces < 0 || $decimalPlaces > 18) {
    die "Error: --decimalPlaces must be >= 0 and <= 18\nStopped";
  }
  $ethDecimalPlaces = $decimalPlaces;
  $daoDecimalPlaces = $decimalPlaces;
} else {
  $ethDecimalPlaces = $DEFAULTETHDECIMALPLACES;
  $daoDecimalPlaces = $DEFAULTDAODECIMALPLACES;
}
$ethNumberLength = $ethDecimalPlaces + 9 + ($ethDecimalPlaces == 0 ? 1 : 0);
$daoNumberLength = $daoDecimalPlaces + 10 + ($daoDecimalPlaces == 0 ? 1 : 0);

if (defined $help) {
  die $helptext;
} elsif (defined $listAccounts) {
  $status = listAccounts($account);
} elsif (defined $listProposals) {
  my $numberOfProposals = getNumberOfProposals();
  printf "Number of proposals: %d\n", $numberOfProposals
    if defined $verbose;
  my ($proposalfrom, $proposalto);
  if (defined $id) {
    if ($id > 0 && $id <= $numberOfProposals) {
      $proposalfrom = $id;
      $proposalto = $id;
    } else {
      die "Error: --id must be >= 1 and <= $numberOfProposals\nStopped";
    }
  } else {
    if (defined $first) {
      if ($first > 0 && $first <= $numberOfProposals) {
        $proposalfrom = $first;
      } else {
        die "Error: --first must be >= 1 and <= $numberOfProposals\nStopped";
      }
    } else {
      $proposalfrom = $DEFAULTFIRST;
    }
    if (defined $last) {
      if ($last > 0 && $last <= $numberOfProposals) {
        $proposalto = $last;
      } else {
        die "Error: --last must be >= 1 and <= $numberOfProposals\nStopped";
      }
    } else {
      $proposalto = $numberOfProposals;
    }
    if (defined $first && defined $last && $first > $last) {
      die "Error: --first must be <= --last\nStopped";
    }
  }
  if (defined $proposalStatus && !($proposalStatus eq "open" || $proposalStatus eq "closed" || $proposalStatus eq "both")) {
    die "Error: --status must be 'open', 'closed' or 'both'\nStopped";
  } elsif (!defined $proposalStatus) {
    $proposalStatus = $DEFAULTSTATUS;
  }
  if (defined $split && !($split eq "exclude" || $split eq "include" || $split eq "only")) {
    die "Error: --split must be 'exclude', 'include' or 'only'\nStopped";
  } elsif (!defined $split) {
    $split = $DEFAULTSPLIT;
  }
  if ($status == 0) {
    $status = listProposals($proposalfrom, $proposalto, $proposalStatus, $split, $account);
  }
} elsif (defined $vote) {
  my $numberOfProposals = getNumberOfProposals();
  printf "Number of proposals: %d\n", $numberOfProposals
    if defined $verbose;
  if (defined $id) {
    if ($id <= 0 || $id > $numberOfProposals) {
      die "Error: --id must be >= 1 and <= $numberOfProposals\nStopped";
    }
  }
  my %accounts = getAccounts($account);
  my $votingAddress;
  if (scalar keys %accounts == 1) {
    die "Error: --account must be specified as a number (e.g. 1) or address (e.g. 0xabc...)\nStopped";
  } else {
    $votingAddress = $accounts{0}->{account};
  }
  if (!defined $votingAddress || !defined $account) {
    die "Error: --account must be specified as a number (e.g. 1) or address (e.g. 0xabc...)\nStopped";
  }
  my $supportProposal;
  if (defined $support) {
    if ($support =~ /[0nN]/) {
      $supportProposal = 0;
    } elsif ($support =~ /[1yY]/) {
      $supportProposal = 1;
    }
  }
  if (!defined $supportProposal) {
    die "Error: --support can be 0, n or N if you don't support the proposal, or 1, y or Y if you support the proposal\nStopped";
  }
  $force = 0
    unless defined $force;
  if ($status == 0) {
    $status = vote($votingAddress, $id, $supportProposal, $force);
  }
} elsif (defined $sumSplits) {
  $status = sumSplits();
} else {
  die $helptext;
}

exit;


# ------------------------------------------------------------------------------
# List accounts
# ------------------------------------------------------------------------------
sub listAccounts {
  my ($account) = @_;

  my %accounts = getAccounts($account);
  print "  # Account                                 " . " " x $ethNumberLength . "ETH" . 
    " " x ($daoNumberLength - 2) . "DAO The DAO transfer blocked by OPEN proposal?\n";
  my $separator = "--- ------------------------------------------ " . "-" x $ethNumberLength . 
    " " . "-" x $daoNumberLength . " ------------------------------------------------------------\n";
  print $separator;
  for (my $i = 0; $i < scalar keys %accounts; $i++) {
    my $account = $accounts{$i};
    if ($account->{account} =~ /Total/) {
      print $separator;
      printf "%3d %-42s %*s %*s\n", $i, $account->{account}, $ethNumberLength, $account->{ethers}, $daoNumberLength, $account->{daos};
    } else {
      my $blockString;
      if ($account->{blocked} != 0 && $account->{open} eq "true") {
        $blockString = "#" . $account->{blocked} . " OPEN until " . getTimeAndDuration($account->{votingDeadline});
      } else {
        $blockString = "";
      }
      printf "%3d %-42s %*s %*s %s\n", $i, $account->{account}, $ethNumberLength, $account->{ethers}, $daoNumberLength, $account->{daos}, $blockString;
    }
  }
  return 0;
}


# ------------------------------------------------------------------------------
# List proposals
# ------------------------------------------------------------------------------
sub listProposals {
  my ($first, $last, $proposalStatus, $split, $account) = @_;
  printf scalar localtime . " listProposals($first, $last, $proposalStatus, $split, " . (defined $account ? $account : "null") . ")\n"
    if defined $verbose;
  
  my %accounts = ();
  if ($checkVotingStatus || $checkPastVotes) {
    %accounts = getAccounts($account);
  }

  my %proposals = getProposals($first, $last, $proposalStatus, $split);
  my %pastVotes = ();
  if ($checkPastVotes) {
    %pastVotes = getPastVotes(\%accounts, \%proposals);
  }

  foreach my $proposalId (sort { $a <=> $b } keys %proposals) {
    my $proposal = $proposals{$proposalId};
    my $recipient = $proposal->{recipient};
    my $amount = $proposal->{amount};
    my $description = $proposal->{description};
    my $descriptionFormatted = $description;
    $descriptionFormatted =~ s/\\n/\n/g;
    $descriptionFormatted =~ s/(\R)(?:\h*\R)+/$1$1/g;
    my $votingDeadline = $proposal->{votingDeadline};
    my $open = $proposal->{open};
    my $proposalPassed = $proposal->{proposalPassed};
    my $proposalDeposit = $proposal->{proposalDeposit};
    my $newCurator = $proposal->{newCurator};
    my $yea = $proposal->{yea};
    my $nay = $proposal->{nay};
    my $creator = $proposal->{creator};
    my $yeaPercent = $proposal->{yeaPercent};
    my $nayPercent = $proposal->{nayPercent};
    my $percent = $proposal->{percent};
    my $quorum = $proposal->{quorum};
    my $close;
    my $passed;
    if ($open) {
      $close = "OPEN until " . getTimeAndDuration($votingDeadline);
      $passed = "";
    } else {
      $close = "CLOSED " . getTimeAndDuration($votingDeadline);
      $passed = $proposalPassed eq "true" ? "PASSED, " : "NOT PASSED, ";
    }
    printf "=" x $terminalWidth . "\n";
    printf "Proposal %d. %s%s\n", $proposalId, $passed, $close;
    printf "Votes       Yea %.0f (%.2f%%) Nay %.0f (%.2f%%) Quorum %.2f%% of %.0f%%\n", 
      $yea, $yeaPercent, $nay, $nayPercent, $percent, $quorum;
    printf "Creator     %s\n", $creator;
    printf "Recipient   %s\n", $recipient;
    printf "Deposit     %s ETH\n", $proposalDeposit;
    printf "Amount      %s ETH\n", $amount;
    printf "New curator %s\n", $newCurator ? "Y" : "N";
    printf "-" x $terminalWidth . "\n";
    print wrap('', '', $descriptionFormatted) . "\n";

    if ($checkVotingStatus || $checkPastVotes) {
      print "-" x $terminalWidth . "\n\n";

      print "  # Account                                 " . " " x $ethNumberLength . "ETH" . 
        " " x ($daoNumberLength - 2) . "DAO (Est)Gas Voting Status\n";
      my $separator = "--- ------------------------------------------ " . "-" x $ethNumberLength . 
        " " . "-" x $daoNumberLength . " -------- -------------\n";
      print $separator;


      # print "  # Account                                                            ETH                        DAO (Est)Gas Voting Status\n";
      # print "--- ------------------------------------------ --------------------------- -------------------------- -------- -------------\n";

      for (my $i = 0; $i < scalar keys %accounts; $i++) {
        my $account = $accounts{$i};
        if (!($account->{account} =~ /Total/)) {
          my $estimatedGas;
          my $votingStatus;
          if ($account->{daos} > 0) {
            $estimatedGas = checkProposalVoteStatus($account->{account}, $proposalId, 0);
            $votingStatus = ($estimatedGas == $ESTIMATEGASMAXGAS) ? "Already voted" : "Not voted yet";
          } else {
            $estimatedGas = 0;
            $votingStatus = "No DAOs";
          }
          if ($checkPastVotes) {
            my ($position, $txHash) = getPastVotingStatus(\%pastVotes, $account->{account}, $proposalId);
            if (defined $position) {
              $estimatedGas = getGasUsed($txHash);
              $votingStatus = $position ne "false" ? "Voted Yea" : "Voted Nay";
            }
          }
          printf "%3d %-42s %*s %*s %8d %-13s\n", $i, $account->{account}, $ethNumberLength, $account->{ethers}, 
            $daoNumberLength, $account->{daos}, $estimatedGas, $votingStatus;
        }
      }
      # print "--- ------------------------------------------ --------------------------- -------------------------- -------- -------------\n";
      print $separator;
    }
    print "=" x $terminalWidth . "\n\n";
  }
  return 0;
}

# ------------------------------------------------------------------------------
# Sum splits
# ------------------------------------------------------------------------------
sub sumSplits {
  my $numberOfProposals = getNumberOfProposals();
  printf "Number of proposals: %d\n", $numberOfProposals
    if defined $verbose;
  my $proposalStatus = "both";
  my $split = "only";
  my %proposals = getProposals(1, $numberOfProposals, $proposalStatus, $split);

  print "  Prop             Yea             Nay Recipient                                  Open   Description                             \n";
  print "------ --------------- --------------- ------------------------------------------ ------ ----------------------------------------\n";
  my ($totalYeaOpen, $totalNayOpen, $totalYeaClosed, $totalNayClosed) = (0, 0, 0, 0);
  foreach my $proposalId (sort { $a <=> $b } keys %proposals) {
    my $proposal = $proposals{$proposalId};
    my $recipient = $proposal->{recipient};
    my $amount = $proposal->{amount};
    my $description = $proposal->{description};
    my $descriptionFormatted = $description;
    $descriptionFormatted =~ s/\\n/\n/g;
    $descriptionFormatted =~ s/(\R)(?:\h*\R)+/$1$1/g;
    my $votingDeadline = $proposal->{votingDeadline};
    my $open = $proposal->{open} ? "OPEN" : "CLOSED";
    my $proposalPassed = $proposal->{proposalPassed};
    my $proposalDeposit = $proposal->{proposalDeposit};
    my $newCurator = $proposal->{newCurator};
    my $yea = $proposal->{yea};
    my $nay = $proposal->{nay};
    if ($proposal->{open}) {
      $totalYeaOpen += $yea;
      $totalNayOpen += $nay;
    } else {
      $totalYeaClosed += $yea;
      $totalNayClosed += $nay;
    }
    my $creator = $proposal->{creator};
    printf "%6d %15.2f %15.2f %s %-6s %-40s\n", $proposalId, $yea, $nay, $recipient, $open, substr($descriptionFormatted, 0, 40);

    # printf "=" x $terminalWidth . "\n\n";
  }
  print "------ --------------- --------------- ------------------------------------------ ------ ----------------------------------------\n";
  printf "SubTot %15.2f %15.2f                                            CLOSED\n", $totalYeaClosed, $totalNayClosed;
  printf "SubTot %15.2f %15.2f                                            OPEN\n", $totalYeaOpen, $totalNayOpen;
  printf "Total  %15.2f %15.2f                                            Both\n", ($totalYeaClosed + $totalYeaOpen), ($totalNayOpen + $totalNayClosed);
  print "------ --------------- --------------- ------------------------------------------ ------ ----------------------------------------\n";
  return 0;
}

# ------------------------------------------------------------------------------
# Vote on a proposal
# ------------------------------------------------------------------------------
sub vote {
  my $status = 0;
  my ($votingAddress, $proposalId, $supportProposal, $force) = @_;
  printf scalar localtime . " vote($votingAddress, $proposalId, $supportProposal, $force)\n"
    if defined $verbose;
  print "vote(address=$votingAddress, proposalId=$proposalId, support=$supportProposal, force=$force)\n";
  my $estimatedGas = checkProposalVoteStatus($votingAddress, $proposalId, $supportProposal);
  if ($estimatedGas == $ESTIMATEGASMAXGAS) {
    print "You have already voted on proposal $proposalId or this account has a 0 DAO balance.\n";
    if (!$force) {
      $status = 2;
    }
  } else {
    print "You have not voted on proposal $proposalId yet. Estimated gas usage $estimatedGas\n";
  }

  # Vote now
  my $password = "";
  if ($status == 0) {
    print "Enter password for $votingAddress to vote (or Control-C to cancel): ";
    system('stty', '-echo');
    $password = <>;
    system('stty', 'echo');
    chomp $password;
    print "\n";
  }

  if ($status == 0 && length($password) > 0) {
    my $command = qq/
var theDAOABIFragment = [{"constant":false,"inputs":[{"name":"_proposalID","type":"uint256"},{"name":"_supportsProposal","type":"bool"}],"name":"vote","outputs":[{"name":"_voteID","type":"uint256"}],"type":"function"}];
var theDAO = eth.contract(theDAOABIFragment).at("$THEDAOADDRESS");
var proposalId = $proposalId;
var supportProposal = $supportProposal;
personal.unlockAccount("$votingAddress", "$password", $UNLOCKACCOUNTSECONDS);
var vote = theDAO.vote($proposalId, $supportProposal, {from: "$votingAddress", gas: $ESTIMATEDGASVOTING});
console.log(vote);
exit;
/;
    my $commandNoPassword = $command;
    $commandNoPassword =~ s/unlockAccount(.*);/unlockAccount("$votingAddress", "********" , $UNLOCKACCOUNTSECONDS);/g;
    printf scalar localtime . " Executing " . $commandNoPassword . "\n"
      if defined $verbose;
    my @output = `echo '$command' | $GETHBINARY attach 2>&1`;
    my $txId;
    for my $line (@output) {
      $line =~ s/unlockAccount(.*);/unlockAccount(*,*,2);/g;
      printf scalar localtime . " " . $line
        if defined $verbose;
      if ($line =~ /account is locked/) {
        printf "Account $votingAddress is locked. Incorrect password?\n";
        $status = 2;
      } elsif ($line =~ /^0x[0-9a-f]*$/) {
        ($txId) = $line =~ /(0x[0-9a-f].*)/;
      }
    }     
    if (defined $txId) {
      printf "Transaction Id $txId\n";
    }
  }
  return $status;
}


# ------------------------------------------------------------------------------
# Get the list of accounts from geth
# ------------------------------------------------------------------------------
sub getAccounts {
  my ($account) = @_;
  $account = ""
    unless defined $account;
  printf scalar localtime . " getAccounts('$account')\n"
    if defined $verbose;
  my %result = ();
  my $command = qq/
var theDAOABIFragment = [{"type":"function","outputs":[{"type":"uint256","name":"balance"}],"name":"balanceOf","inputs":[{"type":"address","name":"_owner"}],"constant":true},{"constant":true,"inputs":[{"name":"","type":"address"}],"name":"blocked","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"proposals","outputs":[{"name":"recipient","type":"address"},{"name":"amount","type":"uint256"},{"name":"description","type":"string"},{"name":"votingDeadline","type":"uint256"},{"name":"open","type":"bool"},{"name":"proposalPassed","type":"bool"},{"name":"proposalHash","type":"bytes32"},{"name":"proposalDeposit","type":"uint256"},{"name":"newCurator","type":"bool"},{"name":"yea","type":"uint256"},{"name":"nay","type":"uint256"},{"name":"creator","type":"address"}],"type":"function"}];
var theDAO = eth.contract(theDAOABIFragment).at("$THEDAOADDRESS");
var i = 0;
var totalEthers = 0;
var totalDaos = 0;
var votingDeadline;
var open;
var account = "$account";
if (account == "") {
  eth.accounts.forEach( function(e) {
    var ethers = web3.fromWei(eth.getBalance(e), "ether");
    var daos = theDAO.balanceOf(e)\/1e16;
    var blocked = theDAO.blocked(e);
    if (blocked > 0) {
      var proposal = theDAO.proposals(blocked);
      votingDeadline = proposal[3];
      open = proposal[4];
    } else {
      votingDeadline = 0;
      open = false;
    }
    totalEthers += parseFloat(ethers);
    totalDaos += parseFloat(daos);
    console.log(i++ + "\\t" + e + "\\t" + ethers.toFixed($ethDecimalPlaces) + "\\t" + daos.toFixed($daoDecimalPlaces) + "\\t" + blocked + "\\t" + votingDeadline + "\\t" + open);
  });
} else if (account.length < 10) {
  var acc = eth.accounts[account];
  var ethers = web3.fromWei(eth.getBalance(acc), "ether");
  var daos = theDAO.balanceOf(acc)\/1e16;
  var blocked = theDAO.blocked(acc);
  if (blocked > 0) {
    var proposal = theDAO.proposals(blocked);
    votingDeadline = proposal[3];
    open = proposal[4];
  } else {
    votingDeadline = 0;
    open = false;
  }
  totalEthers += parseFloat(ethers);
  totalDaos += parseFloat(daos);
  console.log(i++ + "\\t" + acc + "\\t" + ethers.toFixed($ethDecimalPlaces) + "\\t" + daos.toFixed($daoDecimalPlaces) + "\\t" + blocked + "\\t" + votingDeadline + "\\t" + open);
} else if (account.length > 40) {
  var ethers = web3.fromWei(eth.getBalance(account), "ether");
  var daos = theDAO.balanceOf(account)\/1e16;
  var blocked = theDAO.blocked(account);
  if (blocked > 0) {
    var proposal = theDAO.proposals(blocked);
    votingDeadline = proposal[3];
    open = proposal[4];
  } else {
    votingDeadline = 0;
    open = false;
  }
  totalEthers += parseFloat(ethers);
  totalDaos += parseFloat(daos);
  console.log(i++ + "\\t" + account + "\\t" + ethers.toFixed($ethDecimalPlaces) + "\\t" + daos.toFixed($daoDecimalPlaces) + "\\t" + blocked + "\\t" + votingDeadline + "\\t" + open);
}
console.log(i + "\\tTotal\\t" + totalEthers.toFixed($ethDecimalPlaces) + "\\t" + totalDaos.toFixed($daoDecimalPlaces) + "\\t" + 0 + "\\t" + 0 + "\\t" + false);
exit;
/;
  my @output = executeGethCommand($command);
  for my $line (@output) {
    if ($line =~ /\d+\t\S+\t\d+.*\t\d+/) {
      my ($i, $account, $ethers, $daos, $blocked, $votingDeadline, $open) = $line =~ /(\d+)\t(\S+)\t(\d+.*)\t(\d+.*)\t(\S+)\t(\S+)\t(\S+)/;
      printf scalar localtime . " " . $i . " " . $account . " " . $ethers . " " . $daos . " " . $blocked . " " . $votingDeadline . " " . $open . "\n"
        if defined $verbose;
      $result{$i}{account} = $account;
      $result{$i}{ethers} = $ethers;
      $result{$i}{daos} = $daos;
      $result{$i}{blocked} = $blocked;
      $result{$i}{votingDeadline} = $votingDeadline;
      $result{$i}{open} = $open;
    }
  }
  return %result;
}


# ------------------------------------------------------------------------------
# Get the number of proposals from geth
# ------------------------------------------------------------------------------
sub getNumberOfProposals {
  printf scalar localtime . " getNumberOfProposals()\n"
    if defined $verbose;
  my $result = 0;
  my $command = qq/
var theDAOABIFragment = [{"constant":true,"inputs":[],"name":"numberOfProposals","outputs":[{"name":"_numberOfProposals","type":"uint256"}],"type":"function"}];
var theDAO = eth.contract(theDAOABIFragment).at("$THEDAOADDRESS");
console.log("numberOfProposals\\t" + theDAO.numberOfProposals());
exit;
/;
  my @output = executeGethCommand($command);
  for my $line (@output) {
    if ($line =~ /numberOfProposals/) { 
      ($result) = $line =~ /numberOfProposals\t(\d+)/;
    }
  }
  printf scalar localtime . " numberOfProposals: %d\n", $result 
    if defined $verbose;
  return $result;
}


# ------------------------------------------------------------------------------
# Get the list of proposals from geth
# ------------------------------------------------------------------------------
sub getProposals {
  my ($first, $last, $proposalStatus, $split) = @_;
  printf scalar localtime . " getProposals($first, $last, $proposalStatus, $split)\n"
    if defined $verbose;
  my %result = ();
  my $command = qq/
var theDAOABIFragment = [{"constant":true,"inputs":[{"name":"","type":"uint256"}],"name":"proposals","outputs":[{"name":"recipient","type":"address"},{"name":"amount","type":"uint256"},{"name":"description","type":"string"},{"name":"votingDeadline","type":"uint256"},{"name":"open","type":"bool"},{"name":"proposalPassed","type":"bool"},{"name":"proposalHash","type":"bytes32"},{"name":"proposalDeposit","type":"uint256"},{"name":"newCurator","type":"bool"},{"name":"yea","type":"uint256"},{"name":"nay","type":"uint256"},{"name":"creator","type":"address"}],"type":"function"},{"constant":true,"inputs":[],"name":"minQuorumDivisor","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"type":"function","outputs":[{"type":"uint256","name":""}],"name":"totalSupply","inputs":[],"constant":true}];
var theDAO = eth.contract(theDAOABIFragment).at("$THEDAOADDRESS");

var minQuorum = theDAO.minQuorumDivisor();
var totalSupply = theDAO.totalSupply();
console.log("minQuorum " + minQuorum + "\\ttotalSupply " + totalSupply);
var proposalId;
for (proposalId = $first; proposalId <= $last; proposalId++) {
  var proposal = theDAO.proposals(proposalId);
  var open = proposal[4];
  var newCurator = proposal[8];
  console.log(proposalId + " open=" + open + " newCurator=" + newCurator);
  var include = true;
  var status = "$proposalStatus";
  var split = "$split";
  if (status == "open" && open == false) {
    include = false;
  } else if (status == "closed" && open == true) {
    include = false;
  }
  if (split == "exclude" && newCurator == true) {
    include = false;
  } else if (split == "only" && newCurator == false) {
    include = false;
  }
  if (include) {
    var recipient = proposal[0];  
    var amount = web3.fromWei(proposal[1], "ether");
    var description = proposal[2].replace("\\t", " ");
    var votingDeadline = proposal[3];
    var proposalPassed = proposal[5];
    var proposalDeposit = web3.fromWei(proposal[7], "ether");
    var yea = proposal[9] \/ 1e16;
    var nay = proposal[10] \/ 1e16;
    var creator = proposal[11];
    var yeaAndNay = yea + nay;
    var yeaPercent;
    var nayPercent;
    if (yeaAndNay > 0) {
      yeaPercent = yea \/ yeaAndNay * 100;
      nayPercent = nay \/ yeaAndNay * 100;
    } else {
      yeaPercent = 0;
      nayPercent = 0;
    }
    var percent = yeaAndNay \/ totalSupply * 1e16 * 100;
    var quorum = 100 \/ minQuorum;
    console.log(proposalId + "\\t" + recipient + "\\t" + amount + "\\t" + description + "\\t" + 
      votingDeadline + "\\t" + open + "\\t" + proposalPassed + "\\t" + proposalDeposit + "\\t" + 
      newCurator + "\\t" + yea.toFixed(2) + "\\t" + nay.toFixed(2) + "\\t" + creator + "\\t" + yeaPercent.toFixed(2) + "\\t" + 
      nayPercent.toFixed(2) + "\\t" + percent.toFixed(2) + "\\t" + quorum.toFixed(2));
  }
}

exit;
/;
  my @output = executeGethCommand($command);
  for my $line (@output) {
    if ($line =~ /.*\t.*\t.*\t.*\t.*/) {
      my ($proposalId, $recipient, $amount, $description, $votingDeadline, $open, $proposalPassed, $proposalDeposit,
          $newCurator, $yea, $nay, $creator, $yeaPercent, $nayPercent, $percent, $quorum) = split /\t/, $line;
      $result{$proposalId}{proposalId} = $proposalId;
      $result{$proposalId}{recipient} = $recipient;
      $result{$proposalId}{amount} = $amount;
      $result{$proposalId}{description} = $description;
      $result{$proposalId}{votingDeadline} = $votingDeadline;
      $result{$proposalId}{open} = ($open eq "true");
      $result{$proposalId}{proposalPassed} = ($proposalPassed eq "true");
      $result{$proposalId}{proposalDeposit} = $proposalDeposit;
      $result{$proposalId}{newCurator} = ($newCurator eq "true");
      $result{$proposalId}{yea} = $yea;
      $result{$proposalId}{nay} = $nay;
      $result{$proposalId}{creator} = $creator;
      $result{$proposalId}{yeaPercent} = $yeaPercent;
      $result{$proposalId}{nayPercent} = $nayPercent;
      $result{$proposalId}{percent} = $percent;
      $result{$proposalId}{quorum} = $quorum;
    }
  }
  return %result;
}


# ------------------------------------------------------------------------------
# Check whether an account has voted for a proposal
#
# Call data
# > web3.sha3('vote(uint256,bool)').substr(0, 10)
# "0xc9d27afe"
#  0xc9d27afe00000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000
# ------------------------------------------------------------------------------
sub checkProposalVoteStatus {
  my ($account, $proposalId, $support) = @_;
  printf scalar localtime . " checkProposalVoteStatus($account, $proposalId, $support)\n"
    if defined $verbose;
  
  my $data = $VOTESIGNATUREHASH . sprintf("%064x", $proposalId) . sprintf("%064x", $support);
  printf scalar localtime . " eth.estimateGas data " . $data . "\n"
    if defined $verbose;

  my $result = 0;
  my $command = qq/
var result = eth.estimateGas({from: "$account", to: "$THEDAOADDRESS", data: "$data", gas:$ESTIMATEGASMAXGAS});
console.log("result\\t" + result);
exit;
/;
  my @output = executeGethCommand($command);
  for my $line (@output) {
    if ($line =~ /result/) { 
      ($result) = $line =~ /result\t(\S+)/;
    }
  }
  printf scalar localtime . " result: %s\n", $result 
    if defined $verbose;
  return $result;
}


# ------------------------------------------------------------------------------
# Get the list of accounts as a string
# ------------------------------------------------------------------------------
sub getAccountsAsString {
  my %accounts = %{$_[0]};
  my $result = "";
  my $separator = "";

  for (my $i = 0; $i < scalar keys %accounts; $i++) {
    my $account = $accounts{$i};
    if (!($account->{account} =~ /Total/)) {
      $result .= $separator . "\"" . $account->{account} . "\"";
      $separator = ",";
    }
  }
  return "[" . $result . "]";
}


# ------------------------------------------------------------------------------
# Get the list of proposalIDs as a string
# ------------------------------------------------------------------------------
sub getProposalIdsAsString {
  my %proposals = %{$_[0]};
  my $result = "";
  my $separator = "";
  foreach my $proposalId (sort { $a <=> $b } keys %proposals) {
    $result .= $separator . $proposalId;
    $separator = ",";
  }
  return "[" . $result . "]";
}


# ------------------------------------------------------------------------------
# Get past votes
# ------------------------------------------------------------------------------
sub getPastVotes {
  my %accounts = %{$_[0]};
  my %proposals = %{$_[1]};

  printf scalar localtime . " getPastVotes()\n"
    if defined $verbose;

  my $accountsAsString = getAccountsAsString(\%accounts);
  print scalar localtime . " accountsAsString " . $accountsAsString . "\n"
    if defined $verbose;

  my $proposalIdsAsString = getProposalIdsAsString(\%proposals);
  print scalar localtime . " proposalIdsAsString " . $proposalIdsAsString . "\n"
    if defined $verbose;

  my %result = ();
  my $command = qq/
var theDAOABIFragment = [{"anonymous":false,"inputs":[{"indexed":true,"name":"proposalID","type":"uint256"},{"indexed":false,"name":"position","type":"bool"},{"indexed":true,"name":"voter","type":"address"}],"name":"Voted","type":"event"}];
var theDAO = web3.eth.contract(theDAOABIFragment).at("$THEDAOADDRESS");
var theDAOVotedEvent = theDAO.Voted({voter: $accountsAsString, proposalID: $proposalIdsAsString}, {fromBlock: "$THEDAOFIRSTBLOCK", toBlock: "latest"});
theDAOVotedEvent.watch(function(error, result){
  console.log(JSON.stringify(result));
});
exit;
/;
  my @output = executeGethCommand($command);
  my $row = 0;
  for my $line (@output) {
    if ($line =~ /address.*args/) { 
      my ($position, $proposalId, $voter, $blockNumber, $txHash) = 
        $line =~ /position\":(.*),\"proposalID":\"(\d+)\",\"voter\":\"(.*)\"}.*blockNumber\":(\d+),\"event.*tionHash\":\"(.*)\",\"/;
      print scalar localtime . " " . $position . "\t" . $proposalId . "\t" . $voter . "\t" . $blockNumber . "\t" . $txHash . "\n"
        if defined $verbose;
      $result{$row}{position} = $position;
      $result{$row}{proposalId} = $proposalId;
      $result{$row}{voter} = $voter;
      $result{$row}{blockNumber} = $blockNumber;
      $result{$row}{txHash} = $txHash;
      $row++;
    }
  }
  printf scalar localtime . " getPastVotes: %d\n", scalar keys %result 
    if defined $verbose;
  return %result;
}


# ------------------------------------------------------------------------------
# Get past voting status
# ------------------------------------------------------------------------------
sub getPastVotingStatus {
  my %pastVotes = %{$_[0]};
  my $account = $_[1];
  my $proposalId = $_[2];
  my ($position, $txHash);
  foreach my $row (keys %pastVotes) {
    my $pastVote = $pastVotes{$row};
    if ($pastVote->{proposalId} == $proposalId && $pastVote->{voter} eq $account) {
      $position = $pastVote->{position};
      $txHash = $pastVote->{txHash};
      last;
    }
  }
  return ($position, $txHash);
}


# ------------------------------------------------------------------------------
# Get the gas used given the transaction id
# ------------------------------------------------------------------------------
sub getGasUsed {
  my ($txHash) = @_;
  printf scalar localtime . " getGasUsed($txHash)\n"
    if defined $verbose;
  my $result = 0;
  my $command = qq/
var gasUsed = eth.getTransactionReceipt("$txHash").gasUsed;
console.log("gasUsed\\t" + gasUsed);
exit;
/;
  my @output = executeGethCommand($command);
  for my $line (@output) {
    if ($line =~ /gasUsed\t\d+/) {
      ($result) = $line =~ /gasUsed\t(\d+)/;
      printf scalar localtime . " " . $result . "\n"
        if defined $verbose;
    }
  }
  return $result;
}


# ------------------------------------------------------------------------------
# Execute geth attach command with script
# ------------------------------------------------------------------------------
sub executeGethCommand {
  my ($command) = @_;
  printf scalar localtime . " Executing " . $command . "\n"
    if defined $verbose;
  my @result = `echo '$command' | $GETHBINARY attach 2>&1`;
  my $i = 0;
  for my $line (@result) {
    $i++;
    chomp $line;
    if (defined $verbose) {
      printf scalar localtime . " line " . $i . ": " . $line . "\n";
    }
    if ($line =~ /Unable to attach to geth/) {
      die "Cannot attach to a 'geth [options] console' instance. Please start 'geth [options] console'.\nError returned " . 
        $line . "\nStopped";
    } elsif ($line =~ /not found/) {
      die "The command '$GETHBINARY' was not found on your path. Please adjust the \$GETHBINARY variable in $0.\nError returned " .
        $line . "\nStopped";
    }
  }
  return @result;
}


# ------------------------------------------------------------------------------
# Get duration
# ------------------------------------------------------------------------------
sub getTimeAndDuration {
  my ($when) = @_;
  my $diff = $when - time;
  my $positive = $diff > 0;
  $diff = abs($diff);
  my $days = int($diff / (60 * 60 * 24));
  $diff = $diff % (60 * 60 * 24);
  my $hours = int($diff / (60 * 60));
  $diff = $diff % (60 * 60);
  my $minutes = int($diff / 60);
  my $seconds = $diff % 60;
  return (scalar localtime $when) . " [" . ($positive ? "+" : "-") . sprintf("%dd %02dh %02dm %02ds", $days, $hours, $minutes, $seconds) . "]";
}
